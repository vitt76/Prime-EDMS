{% extends 'appearance/base.html' %}

{% load i18n static %}

{% block stylesheets %}
{# CropperJS CSS #}
<link href="{% static 'redactions/node_modules/cropperjs/dist/cropper.css' %}" rel="stylesheet">

<style>
.image-editor { margin-top: 20px; }
.image-editor__title { margin-bottom: 20px; }
.image-editor__canvas-wrapper { border: 1px solid #ddd; min-height: 400px; position: relative; }
.image-editor__canvas { max-width: 100%; }
.image-editor__tools button + button { margin-top: 10px; }
.image-editor__actions .btn { margin-top: 10px; }

/* Стили для активных инструментов и фильтров */
.image-editor__tools button.active {
    background-color: #337ab7;
    border-color: #2e6da4;
}
.image-editor__tools button.active:hover {
    background-color: #286090;
    border-color: #204d74;
}
</style>
{% endblock %}

{% block content %}
<div class="container-fluid image-editor">
    <div class="row">
        <div class="col-md-12">
            <h3 class="image-editor__title">
                <i class="fa fa-pencil-alt"></i>
                {% trans 'Редактор изображений' %}
                {% if document_file %}
                    <small>{{ document_file.filename }}</small>
                {% endif %}
            </h3>
        </div>
    </div>

    <div class="row image-editor__workspace">
        <div class="col-md-9">
            <div class="image-editor__canvas-wrapper">
                <canvas id="image-editor-canvas" class="image-editor__canvas"></canvas>
                <img id="image-editor-source" src="" alt="{{ document_file }}" style="display: none;">
            </div>
        </div>
        <div class="col-md-3">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h4 class="panel-title">{% trans 'Инструменты' %}</h4>
                </div>
                <div class="panel-body image-editor__tools">
                    <!-- Основные инструменты -->
                    <div class="btn-group-vertical btn-block" role="group">
                        <button class="btn btn-default" data-tool="select">
                            <i class="fa fa-mouse-pointer"></i> {% trans 'Выделение' %}
                        </button>
                        <button class="btn btn-default" data-tool="brush">
                            <i class="fa fa-paint-brush"></i> {% trans 'Кисть' %}
                        </button>
                        <button class="btn btn-default" data-tool="eraser">
                            <i class="fa fa-eraser"></i> {% trans 'Ластик' %}
                        </button>
                        <button class="btn btn-default" data-tool="text">
                            <i class="fa fa-font"></i> {% trans 'Текст' %}
                        </button>
                    </div>

                    <hr>

                    <!-- Трансформации -->
                    <div class="btn-group-vertical btn-block" role="group">
                        <button class="btn btn-default btn-sm" data-tool="rotate-left">
                            <i class="fa fa-undo"></i> {% trans 'Поворот влево' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-tool="rotate-right">
                            <i class="fa fa-redo"></i> {% trans 'Поворот вправо' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-tool="flip-horizontal">
                            <i class="fa fa-exchange-alt"></i> {% trans 'Отразить ↔' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-tool="flip-vertical">
                            <i class="fa fa-arrows-alt-v"></i> {% trans 'Отразить ↕' %}
                        </button>
                    </div>

                    <hr>

                    <!-- Параметры рисования -->
                    <div id="drawing-settings" style="display: none;">
                        <label for="brush-size">{% trans 'Размер:' %}</label>
                        <input type="range" id="brush-size" min="1" max="50" value="5">
                        <span id="brush-size-value">5</span>px

                        <label for="brush-color">{% trans 'Цвет:' %}</label>
                        <input type="color" id="brush-color" value="#000000">

                        <label for="brush-opacity">{% trans 'Прозрачность:' %}</label>
                        <input type="range" id="brush-opacity" min="1" max="100" value="100">
                        <span id="brush-opacity-value">100</span>%
                    </div>

                    <!-- Параметры текста -->
                    <div id="text-settings" style="display: none;">
                        <label for="text-input">{% trans 'Текст:' %}</label>
                        <input type="text" id="text-input" class="form-control" placeholder="{% trans 'Введите текст' %}">

                        <label for="text-size">{% trans 'Размер:' %}</label>
                        <input type="range" id="text-size" min="10" max="100" value="20">
                        <span id="text-size-value">20</span>px

                        <label for="text-color">{% trans 'Цвет:' %}</label>
                        <input type="color" id="text-color" value="#000000">

                        <button id="add-text-btn" class="btn btn-primary btn-block btn-sm">
                            <i class="fa fa-plus"></i> {% trans 'Добавить текст' %}
                        </button>
                    </div>

                    <!-- Коррекция цвета -->
                    <hr>
                    <label for="image-editor-brightness">{% trans 'Яркость' %}</label>
                    <input type="range" id="image-editor-brightness" min="-100" max="100" value="0">

                    <label for="image-editor-contrast">{% trans 'Контраст' %}</label>
                    <input type="range" id="image-editor-contrast" min="-100" max="100" value="0">

                    <!-- Дополнительные фильтры -->
                    <hr>
                    <label>{% trans 'Фильтры:' %}</label>
                    <div class="btn-group-vertical btn-block" role="group">
                        <button class="btn btn-default btn-sm" data-filter="none">
                            <i class="fa fa-ban"></i> {% trans 'Без фильтра' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="grayscale">
                            <i class="fa fa-adjust"></i> {% trans 'Ч/Б' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="sepia">
                            <i class="fa fa-sun"></i> {% trans 'Сепия' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="blur">
                            <i class="fa fa-eye-slash"></i> {% trans 'Размытие' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="sharpen">
                            <i class="fa fa-eye"></i> {% trans 'Резкость' %}
                        </button>
                    </div>

                    <!-- Управление историей -->
                    <hr>
                    <div class="btn-group btn-block" role="group">
                        <button id="undo-btn" class="btn btn-default btn-sm" disabled>
                            <i class="fa fa-undo"></i> {% trans 'Отмена' %}
                        </button>
                        <button id="redo-btn" class="btn btn-default btn-sm" disabled>
                            <i class="fa fa-redo"></i> {% trans 'Повтор' %}
                        </button>
                    </div>
                </div>
            </div>

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h4 class="panel-title">{% trans 'Сохранение' %}</h4>
                </div>
                <div class="panel-body image-editor__actions">
                    <textarea id="image-editor-comment" class="form-control" rows="2" placeholder="{% trans 'Комментарий к новой версии' %}"></textarea>

                    <div class="form-group">
                        <label for="image-editor-format">{% trans 'Формат файла:' %}</label>
                        <select id="image-editor-format" class="form-control">
                            <option value="jpeg">JPEG</option>
                            <option value="png">PNG</option>
                            <option value="webp">WebP</option>
                            <option value="tiff">TIFF</option>
                        </select>
                        <small class="help-block">{% trans 'Выберите формат для сохранения отредактированного изображения' %}</small>
                    </div>

                    <button id="image-editor-save" class="btn btn-primary btn-block">
                        <i class="fa fa-save"></i> {% trans 'Сохранить новую версию' %}
                    </button>
                    <a href="#" onclick="history.back()" class="btn btn-default btn-block">
                        <i class="fa fa-arrow-left"></i> {% trans 'Назад к файлу' %}
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block javascript %}
<script>
    // Конфигурация редактора
    window.imageEditorConfig = {
        documentFileId: "{{ document_file.pk|default:'null' }}",
        saveUrl: "{% if document_file.pk %}{% url 'image_editor:save_image' document_file.pk %}{% else %}null{% endif %}",
        csrfToken: "{{ csrf_token }}"
    };

    // Полнофункциональный редактор изображений
    (function() {
        console.log('=== IMAGE EDITOR INITIALIZING ===');

        const canvas = document.getElementById('image-editor-canvas');
        const context = canvas.getContext('2d');
        const sourceImage = document.getElementById('image-editor-source');
        const saveButton = document.getElementById('image-editor-save');
        const commentField = document.getElementById('image-editor-comment');
        const formatField = document.getElementById('image-editor-format');
        const brightnessControl = document.getElementById('image-editor-brightness');
        const contrastControl = document.getElementById('image-editor-contrast');

        // Новые элементы управления
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const brushSizeControl = document.getElementById('brush-size');
        const brushSizeValue = document.getElementById('brush-size-value');
        const brushColorControl = document.getElementById('brush-color');
        const brushOpacityControl = document.getElementById('brush-opacity');
        const brushOpacityValue = document.getElementById('brush-opacity-value');
        const textInput = document.getElementById('text-input');
        const textSizeControl = document.getElementById('text-size');
        const textSizeValue = document.getElementById('text-size-value');
        const textColorControl = document.getElementById('text-color');
        const addTextBtn = document.getElementById('add-text-btn');

        let currentTool = null;
        let currentFilters = {
            brightness: 0,
            contrast: 0,
            filter: 'none'  // none, grayscale, sepia, blur, sharpen
        };

        // Параметры рисования
        let brushSettings = {
            brushSize: 5,
            brushColor: '#000000',
            brushOpacity: 1.0
        };

        // Параметры текста
        let textConfig = {
            text: '',
            fontSize: 20,
            color: '#000000',
            x: 50,
            y: 50
        };

        // История операций для undo/redo
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 20;

        // Функция для применения box blur
        function applyBoxBlur(data, width, height, radius) {
            const tempData = new Uint8ClampedArray(data);
            const radiusSquared = radius * radius;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0, count = 0;

                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const offset = (ny * width + nx) * 4;
                                r += tempData[offset];
                                g += tempData[offset + 1];
                                b += tempData[offset + 2];
                                a += tempData[offset + 3];
                                count++;
                            }
                        }
                    }

                    const offset = (y * width + x) * 4;
                    data[offset] = r / count;
                    data[offset + 1] = g / count;
                    data[offset + 2] = b / count;
                    data[offset + 3] = a / count;
                }
            }
        }

        // Функции работы с историей
        function saveToHistory() {
            if (canvas.width === 0 || canvas.height === 0) {
                return;
            }

            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            history = history.slice(0, historyIndex + 1);
            history.push({
                imageData: new ImageData(
                    new Uint8ClampedArray(imageData.data),
                    imageData.width,
                    imageData.height
                ),
                width: canvas.width,
                height: canvas.height
            });

            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }

            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreFromHistory();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreFromHistory();
            }
        }

        function restoreFromHistory() {
            if (historyIndex >= 0 && historyIndex < history.length) {
                const historyItem = history[historyIndex];
                canvas.width = historyItem.width;
                canvas.height = historyItem.height;
                context.putImageData(historyItem.imageData, 0, 0);
                applyFilters();
            }
            updateHistoryButtons();
        }

        function updateHistoryButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // Инициализация Canvas
        function initializeCanvas() {
            const documentFileId = window.imageEditorConfig.documentFileId;
            const mimetype = '{{ document_file.mimetype|default:"" }}';
            const filename = '{{ document_file.filename|default:"" }}';

            console.log('Initializing canvas with:', {
                documentFileId,
                mimetype,
                filename,
                config: window.imageEditorConfig
            });

            if (!documentFileId || documentFileId === 'null') {
                console.error('Document file ID is not available');
                showError('Файл не найден или недоступен.');
                return;
            }

            if (!mimetype || !mimetype.startsWith('image/')) {
                console.error('File is not an image:', mimetype);
                showError('Выбранный файл не является изображением.');
                return;
            }

            const apiUrl = '{{ document_file.get_api_image_url|default:"" }}';
            console.log('API URL:', apiUrl);

            if (!apiUrl || apiUrl.trim() === '') {
                console.error('API image URL is not available or empty');
                showError('Не удалось получить URL изображения.');
                return;
            }

            // Показываем индикатор загрузки
            const canvasWrapper = document.querySelector('.image-editor__canvas-wrapper');
            const loadingIndicator = document.createElement('div');
            loadingIndicator.innerHTML = `
                <div class="text-center" style="padding: 40px;">
                    <i class="fa fa-spinner fa-spin fa-2x"></i>
                    <p style="margin-top: 10px;">Загрузка изображения...</p>
                </div>
            `;
            canvasWrapper.appendChild(loadingIndicator);

            sourceImage.src = apiUrl;
            sourceImage.onload = function() {
                console.log('Image loaded successfully:', sourceImage.naturalWidth, 'x', sourceImage.naturalHeight);
                canvas.width = sourceImage.naturalWidth;
                canvas.height = sourceImage.naturalHeight;

                if (canvas.width > 0 && canvas.height > 0) {
                    context.drawImage(sourceImage, 0, 0);

                    if (loadingIndicator && loadingIndicator.parentNode) {
                        loadingIndicator.parentNode.removeChild(loadingIndicator);
                    }

                    setTimeout(() => saveToHistory(), 100);
                } else {
                    console.error('Failed to load image - invalid dimensions');
                    if (loadingIndicator && loadingIndicator.parentNode) {
                        loadingIndicator.parentNode.removeChild(loadingIndicator);
                    }
                    showError('Изображение имеет некорректные размеры.');
                }
            };

            sourceImage.onerror = function(e) {
                console.error('Failed to load image from API URL:', apiUrl, e);

                if (loadingIndicator && loadingIndicator.parentNode) {
                    loadingIndicator.parentNode.removeChild(loadingIndicator);
                }

                console.log('Trying fallback loading...');
                fetch('/documents/documents/files/' + documentFileId + '/preview/', {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': "{{ csrf_token }}",
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    credentials: 'same-origin'
                })
                .then(response => {
                    console.log('Fallback fetch response:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    console.log('Blob received, size:', blob.size);
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                })
                .then(dataUrl => {
                    console.log('Data URL created, setting as src');
                    sourceImage.src = dataUrl;
                })
                .catch(error => {
                    console.error('Fallback loading also failed:', error);
                    showError('Не удалось загрузить изображение. Попробуйте другой файл.');
                });
            };

            if (sourceImage.complete) {
                sourceImage.onload();
            }
        }

        // Обработчик клика по canvas для размещения текста
        function handleCanvasClick(event) {
            if (currentTool !== 'text') return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            textConfig.x = (event.clientX - rect.left) * scaleX;
            textConfig.y = (event.clientY - rect.top) * scaleY;
        }

        // Сохранение изображения
        function handleSave() {
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;

            tempContext.drawImage(canvas, 0, 0);

            if (currentFilters.brightness !== 0 || currentFilters.contrast !== 0 || currentFilters.filter !== 'none') {
                const imageData = tempContext.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;

                const brightness = (currentFilters.brightness / 100) + 1;
                const contrast = (currentFilters.contrast / 100) + 1;

                for (let i = 0; i < data.length; i += 4) {
                    data[i] *= brightness;
                    data[i + 1] *= brightness;
                    data[i + 2] *= brightness;

                    data[i] = ((data[i] - 128) * contrast) + 128;
                    data[i + 1] = ((data[i + 1] - 128) * contrast) + 128;
                    data[i + 2] = ((data[i + 2] - 128) * contrast) + 128;
                }

                switch (currentFilters.filter) {
                    case 'grayscale':
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                            data[i] = data[i + 1] = data[i + 2] = gray;
                        }
                        break;
                    case 'sepia':
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i], g = data[i + 1], b = data[i + 2];
                            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                            data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                            data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                        }
                        break;
                    case 'blur':
                        applyBoxBlur(data, tempCanvas.width, tempCanvas.height, 2);
                        break;
                    case 'sharpen':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, data[i] * 1.2);
                            data[i + 1] = Math.min(255, data[i + 1] * 1.2);
                            data[i + 2] = Math.min(255, data[i + 2] * 1.2);
                        }
                        break;
                }

                tempContext.putImageData(imageData, 0, 0);
            }

            const selectedFormat = formatField.value;
            const mimeType = selectedFormat === 'jpeg' ? 'image/jpeg' :
                             selectedFormat === 'png' ? 'image/png' :
                             selectedFormat === 'webp' ? 'image/webp' :
                             selectedFormat === 'tiff' ? 'image/tiff' : 'image/png';

            tempCanvas.toBlob(function(blob) {
                if (!blob) {
                    alert('Не удалось получить данные изображения');
                    return;
                }

                const fileName = `edited-image.${selectedFormat}`;
                const formData = new FormData();
                formData.append('image_content', blob, fileName);
                formData.append('comment', commentField.value);
                formData.append('format', selectedFormat);

                fetch(window.imageEditorConfig.saveUrl, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': window.imageEditorConfig.csrfToken
                    },
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Новая версия успешно сохранена.');
                        window.location.href = '/documents/documents/files/' + data.document_file_id + '/preview/';
                    } else {
                        alert('Ошибка при сохранении: ' + JSON.stringify(data.errors));
                    }
                })
                .catch(error => {
                    console.error('Save error:', error);
                    alert('Ошибка при сохранении файла.');
                });
            }, mimeType);
        }

        // Обработчики инструментов
        function handleToolClick(event) {
            const button = event.currentTarget;
            const tool = button.getAttribute('data-tool');

            document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            document.getElementById('drawing-settings').style.display = 'none';
            document.getElementById('text-settings').style.display = 'none';

            currentTool = tool;

            switch (tool) {
                case 'brush':
                case 'eraser':
                    document.getElementById('drawing-settings').style.display = 'block';
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'text':
                    document.getElementById('text-settings').style.display = 'block';
                    canvas.style.cursor = 'text';
                    break;
                case 'select':
                    canvas.style.cursor = 'default';
                    break;
            }
        }

        // Поворот изображения
        function rotateImage(degrees) {
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');

            if (Math.abs(degrees) === 90) {
                tempCanvas.width = canvas.height;
                tempCanvas.height = canvas.width;

                tempContext.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                tempContext.rotate(degrees * Math.PI / 180);
                tempContext.translate(-canvas.width / 2, -canvas.height / 2);
                tempContext.drawImage(canvas, 0, 0);

                canvas.width = tempCanvas.width;
                canvas.height = tempCanvas.height;
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(tempCanvas, 0, 0);
            }
        }

        // Отражение изображения
        function flipImage(direction) {
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;

            tempContext.save();

            if (direction === 'horizontal') {
                tempContext.scale(-1, 1);
                tempContext.drawImage(canvas, -canvas.width, 0);
            } else if (direction === 'vertical') {
                tempContext.scale(1, -1);
                tempContext.drawImage(canvas, 0, -canvas.height);
            }

            tempContext.restore();

            context.clearRect(0, 0, canvas.width, canvas.height);
            context.drawImage(tempCanvas, 0, 0);
        }

        // Применение фильтров
        function applyFilters() {
            let filterParts = [];

            if (currentFilters.brightness !== 0 || currentFilters.contrast !== 0) {
                const brightness = (currentFilters.brightness / 100) + 1;
                const contrast = (currentFilters.contrast / 100) + 1;
                filterParts.push(`brightness(${brightness}) contrast(${contrast})`);
            }

            switch (currentFilters.filter) {
                case 'grayscale':
                    filterParts.push('grayscale(100%)');
                    break;
                case 'sepia':
                    filterParts.push('sepia(100%)');
                    break;
                case 'blur':
                    filterParts.push('blur(2px)');
                    break;
                case 'sharpen':
                    filterParts.push('contrast(1.2) brightness(1.1)');
                    break;
                case 'none':
                default:
                    break;
            }

            const filterString = filterParts.length > 0 ? filterParts.join(' ') : 'none';
            canvas.style.filter = filterString;
        }

        function resetFilters() {
            currentFilters.brightness = 0;
            currentFilters.contrast = 0;
            currentFilters.filter = 'none';
            brightnessControl.value = 0;
            contrastControl.value = 0;
            canvas.style.filter = 'none';

            document.querySelectorAll('[data-filter]').forEach(btn => btn.classList.remove('active'));
            document.querySelector('[data-filter="none"]').classList.add('active');
        }

        function handleBrightnessChange(event) {
            currentFilters.brightness = parseInt(event.target.value);
            applyFilters();
        }

        function handleContrastChange(event) {
            currentFilters.contrast = parseInt(event.target.value);
            applyFilters();
        }

        function handleFilterClick(event) {
            const button = event.currentTarget;
            const filter = button.getAttribute('data-filter');

            document.querySelectorAll('[data-filter]').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            currentFilters.filter = filter;
            applyFilters();
        }

        function handleBrushSizeChange(event) {
            brushSettings.brushSize = parseInt(event.target.value);
            brushSizeValue.textContent = brushSettings.brushSize;
        }

        function handleBrushColorChange(event) {
            brushSettings.brushColor = event.target.value;
        }

        function handleBrushOpacityChange(event) {
            brushSettings.brushOpacity = parseInt(event.target.value) / 100;
            brushOpacityValue.textContent = event.target.value;
        }

        function handleTextSizeChange(event) {
            textConfig.fontSize = parseInt(event.target.value);
            textSizeValue.textContent = textConfig.fontSize;
        }

        function handleTextColorChange(event) {
            textConfig.color = event.target.value;
        }

        function handleTextInputChange(event) {
            textConfig.text = event.target.value;
        }

        function addText() {
            if (!textConfig.text.trim()) {
                alert('Введите текст для добавления');
                return;
            }

            saveToHistory();

            context.save();
            context.font = `${textConfig.fontSize}px Arial`;
            context.fillStyle = textConfig.color;
            context.fillText(textConfig.text, textConfig.x, textConfig.y);
            context.restore();
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #f8d7da; color: #721c24; padding: 20px; border: 1px solid #f5c6cb; border-radius: 5px; z-index: 10000;';
            errorDiv.innerHTML = `<strong>Ошибка:</strong> ${message}<br><button onclick="this.parentNode.remove()" style="margin-top: 10px;">Закрыть</button>`;
            document.body.appendChild(errorDiv);
        }

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        function startDrawing(event) {
            if (currentTool !== 'brush' && currentTool !== 'eraser') return;

            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            lastX = (event.clientX - rect.left) * scaleX;
            lastY = (event.clientY - rect.top) * scaleY;

            saveToHistory();
        }

        function draw(event) {
            if (!isDrawing || (currentTool !== 'brush' && currentTool !== 'eraser')) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const currentX = (event.clientX - rect.left) * scaleX;
            const currentY = (event.clientY - rect.top) * scaleY;

            context.save();

            if (currentTool === 'brush') {
                context.globalAlpha = brushSettings.brushOpacity;
                context.strokeStyle = brushSettings.brushColor;
                context.lineWidth = brushSettings.brushSize;
                context.lineCap = 'round';
                context.lineJoin = 'round';
            } else if (currentTool === 'eraser') {
                context.globalCompositeOperation = 'destination-out';
                context.lineWidth = brushSettings.brushSize;
            }

            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(currentX, currentY);
            context.stroke();

            context.restore();

            lastX = currentX;
            lastY = currentY;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // Инициализация
        function init() {
            console.log('Initializing image editor...');

            initializeCanvas();

            document.querySelectorAll('[data-tool]').forEach(button => {
                button.addEventListener('click', handleToolClick);
            });

            brightnessControl.addEventListener('input', handleBrightnessChange);
            contrastControl.addEventListener('input', handleContrastChange);

            document.querySelectorAll('[data-filter]').forEach(button => {
                button.addEventListener('click', handleFilterClick);
            });

            brushSizeControl.addEventListener('input', handleBrushSizeChange);
            brushColorControl.addEventListener('input', handleBrushColorChange);
            brushOpacityControl.addEventListener('input', handleBrushOpacityChange);

            textInput.addEventListener('input', handleTextInputChange);
            textSizeControl.addEventListener('input', handleTextSizeChange);
            textColorControl.addEventListener('input', handleTextColorChange);
            addTextBtn.addEventListener('click', addText);

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('click', handleCanvasClick);

            saveButton.addEventListener('click', handleSave);

            document.querySelector('[data-filter="none"]').classList.add('active');
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
</script>
{% endblock %}
