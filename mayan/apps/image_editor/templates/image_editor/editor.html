{% extends 'appearance/base.html' %}

{% load i18n static %}

{% block stylesheets %}
{# CropperJS CSS #}
<link href="{% static 'redactions/node_modules/cropperjs/dist/cropper.css' %}" rel="stylesheet">

<style>
.image-editor { margin-top: 20px; }
.image-editor__title { margin-bottom: 20px; }
.image-editor__canvas-wrapper { border: 1px solid #ddd; min-height: 400px; position: relative; }
.image-editor__canvas { max-width: 100%; }
.image-editor__tools button + button { margin-top: 10px; }
.image-editor__actions .btn { margin-top: 10px; }

/* Стили для активных инструментов и фильтров */
.image-editor__tools button.active {
    background-color: #337ab7;
    border-color: #2e6da4;
}
.image-editor__tools button.active:hover {
    background-color: #286090;
    border-color: #204d74;
}
</style>
{% endblock %}

{% block content %}
<div class="container-fluid image-editor">
    <div class="row">
        <div class="col-md-12">
            <h3 class="image-editor__title">
                <i class="fa fa-pencil-alt"></i>
                {% trans 'Редактор изображений' %}
                {% if document_file %}
                    <small>{{ document_file.filename }}</small>
                {% endif %}
            </h3>
        </div>
    </div>

    <div class="row image-editor__workspace">
        <div class="col-md-9">
            <div class="image-editor__canvas-wrapper">
                <canvas id="image-editor-canvas" class="image-editor__canvas"></canvas>
                <img id="image-editor-source" src="" alt="{{ document_file }}" style="display: none;">
            </div>
        </div>
        <div class="col-md-3">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h4 class="panel-title">{% trans 'Инструменты' %}</h4>
                </div>
                <div class="panel-body image-editor__tools">
                    <!-- Основные инструменты -->
                    <div class="btn-group-vertical btn-block" role="group">
                        <button class="btn btn-default" data-tool="select">
                            <i class="fa fa-mouse-pointer"></i> {% trans 'Выделение' %}
                        </button>
                        <button class="btn btn-default" data-tool="crop">
                            <i class="fa fa-crop"></i> {% trans 'Обрезка' %}
                        </button>
                        <button class="btn btn-default" data-tool="brush">
                            <i class="fa fa-paint-brush"></i> {% trans 'Кисть' %}
                        </button>
                        <button class="btn btn-default" data-tool="eraser">
                            <i class="fa fa-eraser"></i> {% trans 'Ластик' %}
                        </button>
                        <button class="btn btn-default" data-tool="text">
                            <i class="fa fa-font"></i> {% trans 'Текст' %}
                        </button>
                        <button class="btn btn-default" data-tool="watermark">
                            <i class="fa fa-tint"></i> {% trans 'Водяной знак' %}
                        </button>
                    </div>

                    <hr>

                    <!-- Трансформации -->
                    <div class="btn-group-vertical btn-block" role="group">
                        <button class="btn btn-default btn-sm" data-tool="rotate-left">
                            <i class="fa fa-undo"></i> {% trans 'Поворот влево' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-tool="rotate-right">
                            <i class="fa fa-redo"></i> {% trans 'Поворот вправо' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-tool="flip-horizontal">
                            <i class="fa fa-exchange-alt"></i> {% trans 'Отразить ↔' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-tool="flip-vertical">
                            <i class="fa fa-arrows-alt-v"></i> {% trans 'Отразить ↕' %}
                        </button>
                    </div>

                    <hr>

                    <!-- Параметры рисования -->
                    <div id="drawing-settings" style="display: none;">
                        <label for="brush-size">{% trans 'Размер:' %}</label>
                        <input type="range" id="brush-size" min="1" max="50" value="5">
                        <span id="brush-size-value">5</span>px

                        <label for="brush-color">{% trans 'Цвет:' %}</label>
                        <input type="color" id="brush-color" value="#000000">

                        <label for="brush-opacity">{% trans 'Прозрачность:' %}</label>
                        <input type="range" id="brush-opacity" min="1" max="100" value="100">
                        <span id="brush-opacity-value">100</span>%
                    </div>

                    <!-- Параметры текста -->
                    <div id="text-settings" style="display: none;">
                        <label for="text-input">{% trans 'Текст:' %}</label>
                        <input type="text" id="text-input" class="form-control" placeholder="{% trans 'Введите текст' %}">

                        <label for="text-size">{% trans 'Размер:' %}</label>
                        <input type="range" id="text-size" min="10" max="100" value="20">
                        <span id="text-size-value">20</span>px

                        <label for="text-color">{% trans 'Цвет:' %}</label>
                        <input type="color" id="text-color" value="#000000">

                        <button id="add-text-btn" class="btn btn-primary btn-block btn-sm">
                            <i class="fa fa-plus"></i> {% trans 'Добавить текст' %}
                        </button>
                    </div>

                    <!-- Настройки водяного знака -->
                    <div id="watermark-settings" style="display: none;">
                        <label for="watermark-select">{% trans 'Выберите водяной знак:' %}</label>
                        <select id="watermark-select" class="form-control">
                            <option value="">{% trans 'Загрузка...' %}</option>
                        </select>

                        <div class="form-group" style="margin-top: 10px;">
                            <label for="watermark-opacity">{% trans 'Прозрачность:' %}</label>
                            <input type="range" id="watermark-opacity" min="1" max="100" value="50">
                            <span id="watermark-opacity-value">50</span>%
                        </div>

                        <div class="form-group">
                            <label for="watermark-position">{% trans 'Позиция:' %}</label>
                            <select id="watermark-position" class="form-control">
                                <option value="center">{% trans 'Центр' %}</option>
                                <option value="top-left">{% trans 'Верхний левый угол' %}</option>
                                <option value="top-right">{% trans 'Верхний правый угол' %}</option>
                                <option value="bottom-left">{% trans 'Нижний левый угол' %}</option>
                                <option value="bottom-right">{% trans 'Нижний правый угол' %}</option>
                                <option value="custom">{% trans 'Пользовательская' %}</option>
                            </select>
                        </div>

                        <div id="watermark-custom-position" style="display: none;">
                            <div class="form-group">
                                <label for="watermark-x">X (px):</label>
                                <input type="number" id="watermark-x" class="form-control" min="0">
                            </div>
                            <div class="form-group">
                                <label for="watermark-y">Y (px):</label>
                                <input type="number" id="watermark-y" class="form-control" min="0">
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="watermark-scale">{% trans 'Масштаб:' %}</label>
                            <input type="range" id="watermark-scale" min="10" max="200" value="100">
                            <span id="watermark-scale-value">100</span>%
                        </div>

                        <button id="apply-watermark-btn" class="btn btn-info btn-block btn-sm">
                            <i class="fa fa-plus"></i> {% trans 'Применить водяной знак' %}
                        </button>
                    </div>

                    <!-- Управление обрезкой -->
                    <div id="crop-settings" style="display: none;">
                        <p class="text-info small">{% trans 'Выделите область обрезки, перетаскивая углы и края синей рамки' %}</p>

                        <!-- Точные размеры -->
                        <div class="form-group">
                            <label for="crop-width" class="control-label">{% trans 'Ширина (px):' %}</label>
                            <input type="number" id="crop-width" class="form-control" min="1" placeholder="{% trans 'Ширина' %}">
                        </div>
                        <div class="form-group">
                            <label for="crop-height" class="control-label">{% trans 'Высота (px):' %}</label>
                            <input type="number" id="crop-height" class="form-control" min="1" placeholder="{% trans 'Высота' %}">
                        </div>
                        <div class="checkbox">
                            <label>
                                <input type="checkbox" id="crop-maintain-ratio"> {% trans 'Сохранять пропорции' %}
                            </label>
                        </div>
                        <button id="apply-size-btn" class="btn btn-info btn-sm btn-block">
                            <i class="fa fa-arrows-alt"></i> {% trans 'Применить размеры' %}
                        </button>

                        <hr>

                        <div class="btn-group btn-block" role="group">
                            <button id="apply-crop-btn" class="btn btn-success btn-sm">
                                <i class="fa fa-check"></i> {% trans 'Применить обрезку' %}
                            </button>
                            <button id="cancel-crop-btn" class="btn btn-default btn-sm">
                                <i class="fa fa-times"></i> {% trans 'Отмена' %}
                            </button>
                        </div>
                    </div>

                    <!-- Коррекция цвета -->
                    <hr>
                    <label for="image-editor-brightness">{% trans 'Яркость' %}</label>
                    <input type="range" id="image-editor-brightness" min="-100" max="100" value="0">

                    <label for="image-editor-contrast">{% trans 'Контраст' %}</label>
                    <input type="range" id="image-editor-contrast" min="-100" max="100" value="0">

                    <!-- Дополнительные фильтры -->
                    <hr>
                    <label>{% trans 'Фильтры:' %}</label>
                    <div class="btn-group-vertical btn-block" role="group">
                        <button class="btn btn-default btn-sm" data-filter="none">
                            <i class="fa fa-ban"></i> {% trans 'Без фильтра' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="grayscale">
                            <i class="fa fa-adjust"></i> {% trans 'Ч/Б' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="sepia">
                            <i class="fa fa-sun"></i> {% trans 'Сепия' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="blur">
                            <i class="fa fa-eye-slash"></i> {% trans 'Размытие' %}
                        </button>
                        <button class="btn btn-default btn-sm" data-filter="sharpen">
                            <i class="fa fa-eye"></i> {% trans 'Резкость' %}
                        </button>
                    </div>

                    <!-- Управление историей -->
                    <hr>
                    <div class="btn-group btn-block" role="group">
                        <button id="undo-btn" class="btn btn-default btn-sm" disabled>
                            <i class="fa fa-undo"></i> {% trans 'Отмена' %}
                        </button>
                        <button id="redo-btn" class="btn btn-default btn-sm" disabled>
                            <i class="fa fa-redo"></i> {% trans 'Повтор' %}
                        </button>
                    </div>
                </div>
            </div>

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h4 class="panel-title">{% trans 'Сохранение' %}</h4>
                </div>
                <div class="panel-body image-editor__actions">
                    <textarea id="image-editor-comment" class="form-control" rows="2" placeholder="{% trans 'Комментарий к новой версии' %}"></textarea>

                    <div class="form-group">
                        <label for="image-editor-format">{% trans 'Формат файла:' %}</label>
                        <select id="image-editor-format" class="form-control">
                            <option value="jpeg">JPEG</option>
                            <option value="png">PNG</option>
                            <option value="webp">WebP</option>
                            <option value="tiff">TIFF</option>
                        </select>
                        <small class="help-block">{% trans 'Выберите формат для сохранения отредактированного изображения' %}</small>
                    </div>

                    <button id="image-editor-save" class="btn btn-primary btn-block">
                        <i class="fa fa-save"></i> {% trans 'Сохранить новую версию' %}
                    </button>
                    <a href="{% url 'documents:document_file_preview' document_file.pk %}" class="btn btn-default btn-block">
                        <i class="fa fa-arrow-left"></i> {% trans 'Назад к файлу' %}
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block javascript %}
<script>
    // Конфигурация редактора
    window.imageEditorConfig = {
        documentFileId: "{{ document_file.pk|default:'null' }}",
        saveUrl: "{% if document_file.pk %}{% url 'image_editor:save_image' document_file.pk %}{% else %}null{% endif %}",
        csrfToken: "{{ csrf_token }}"
    };

    // Полнофункциональный редактор изображений
    (function() {
        console.log('=== IMAGE EDITOR INITIALIZING ===');

        // Загрузка CropperJS
        let cropperJSLoaded = false;
        $.getScript("{% static 'redactions/node_modules/cropperjs/dist/cropper.js' %}")
        .done(function (script, textStatus) {
            console.log('CropperJS loaded successfully');
            cropperJSLoaded = true;
        })
        .fail(function (jqxhr, settings, exception) {
            console.error('Failed to load CropperJS:', exception);
        });

        const canvas = document.getElementById('image-editor-canvas');
        const context = canvas.getContext('2d');
        const sourceImage = document.getElementById('image-editor-source');
        const saveButton = document.getElementById('image-editor-save');
        const commentField = document.getElementById('image-editor-comment');
        const formatField = document.getElementById('image-editor-format');
        const brightnessControl = document.getElementById('image-editor-brightness');
        const contrastControl = document.getElementById('image-editor-contrast');

        // Новые элементы управления
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const brushSizeControl = document.getElementById('brush-size');
        const brushSizeValue = document.getElementById('brush-size-value');
        const brushColorControl = document.getElementById('brush-color');
        const brushOpacityControl = document.getElementById('brush-opacity');
        const brushOpacityValue = document.getElementById('brush-opacity-value');
        const textInput = document.getElementById('text-input');
        const textSizeControl = document.getElementById('text-size');
        const textSizeValue = document.getElementById('text-size-value');
        const textColorControl = document.getElementById('text-color');
        const addTextBtn = document.getElementById('add-text-btn');

        let currentTool = null;
        let currentFilters = {
            brightness: 0,
            contrast: 0,
            filter: 'none'  // none, grayscale, sepia, blur, sharpen
        };

        // Параметры рисования
        let brushSettings = {
            brushSize: 5,
            brushColor: '#000000',
            brushOpacity: 1.0
        };

        // Параметры текста
        let textConfig = {
            text: '',
            fontSize: 20,
            color: '#000000',
            x: 50,
            y: 50
        };

        // CropperJS для обрезки
        let cropper = null;

        // Переменная для хранения состояния canvas перед cropper
        let canvasStateBeforeCrop = null;

        // Водяные знаки
        let currentWatermarkImage = null;
        let watermarksLoaded = false;

        // История операций для undo/redo
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 20;

        // Функция для применения box blur
        function applyBoxBlur(data, width, height, radius) {
            const tempData = new Uint8ClampedArray(data);
            const radiusSquared = radius * radius;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0, count = 0;

                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const offset = (ny * width + nx) * 4;
                                r += tempData[offset];
                                g += tempData[offset + 1];
                                b += tempData[offset + 2];
                                a += tempData[offset + 3];
                                count++;
                            }
                        }
                    }

                    const offset = (y * width + x) * 4;
                    data[offset] = r / count;
                    data[offset + 1] = g / count;
                    data[offset + 2] = b / count;
                    data[offset + 3] = a / count;
                }
            }
        }

        // Функции работы с историей
        function saveToHistory() {
            if (canvas.width === 0 || canvas.height === 0) {
                return;
            }

            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            history = history.slice(0, historyIndex + 1);
            history.push({
                imageData: new ImageData(
                    new Uint8ClampedArray(imageData.data),
                    imageData.width,
                    imageData.height
                ),
                width: canvas.width,
                height: canvas.height
            });

            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }

            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreFromHistory();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreFromHistory();
            }
        }

        function restoreFromHistory() {
            if (historyIndex >= 0 && historyIndex < history.length) {
                const historyItem = history[historyIndex];
                canvas.width = historyItem.width;
                canvas.height = historyItem.height;
                context.putImageData(historyItem.imageData, 0, 0);
                applyFilters();
            }
            updateHistoryButtons();
        }

        function updateHistoryButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // Функции работы с CropperJS
        function updateCropSizeInputs() {
            if (cropper) {
                const cropData = cropper.getData();
                document.getElementById('crop-width').value = Math.round(cropData.width);
                document.getElementById('crop-height').value = Math.round(cropData.height);
            }
        }

        function applyCropSize() {
            if (!cropper) return;

            const width = parseInt(document.getElementById('crop-width').value);
            const height = parseInt(document.getElementById('crop-height').value);

            if (!width || !height || width <= 0 || height <= 0) {
                alert('Введите корректные размеры');
                return;
            }

            const currentData = cropper.getData();

            if (document.getElementById('crop-maintain-ratio').checked && currentData.width && currentData.height) {
                const ratio = currentData.width / currentData.height;
                const newData = { ...currentData };

                if (width / height > ratio) {
                    newData.height = height;
                    newData.width = height * ratio;
                } else {
                    newData.width = width;
                    newData.height = width / ratio;
                }

                cropper.setData(newData);
            } else {
                cropper.setData({
                    ...currentData,
                    width: width,
                    height: height
                });
            }

            updateCropSizeInputs();
        }

        function initCropper() {
            console.log('Initializing Cropper...');

            if (!cropperJSLoaded) {
                console.warn('CropperJS not loaded yet');
                alert('CropperJS загружается, попробуйте еще раз через секунду');
                return;
            }

            if (cropper) {
                cropper.destroy();
            }

            // Сохраняем текущее состояние canvas перед активацией cropper
            try {
                canvasStateBeforeCrop = {
                    imageData: context.getImageData(0, 0, canvas.width, canvas.height),
                    width: canvas.width,
                    height: canvas.height
                };
            } catch (e) {
                console.warn('Could not save canvas state:', e);
                canvasStateBeforeCrop = null;
            }

            // Создаем временное изображение для cropper
            const tempImage = new Image();
            tempImage.src = canvas.toDataURL();

            tempImage.onload = function() {
                // Заменяем canvas на изображение для cropper
                const canvasContainer = canvas.parentNode;
                const cropperContainer = document.createElement('div');
                cropperContainer.id = 'cropper-container';
                cropperContainer.style.position = 'relative';
                cropperContainer.style.maxWidth = '100%';

                canvasContainer.replaceChild(cropperContainer, canvas);

                const cropperImage = document.createElement('img');
                cropperImage.src = tempImage.src;
                cropperImage.style.maxWidth = '100%';
                cropperContainer.appendChild(cropperImage);

                cropper = new Cropper(cropperImage, {
                    aspectRatio: NaN, // Свободная обрезка
                    viewMode: 1,
                    dragMode: 'move',
                    responsive: true,
                    restore: false,
                    checkCrossOrigin: false,
                    checkOrientation: false,
                    modal: true,
                    guides: true,
                    center: true,
                    highlight: true,
                    background: true,
                    autoCrop: true,
                    autoCropArea: 0.8,
                    movable: true,
                    rotatable: true,
                    scalable: true,
                    zoomable: true,
                    zoomOnTouch: true,
                    zoomOnWheel: true,
                    wheelZoomRatio: 0.1,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: true,
                    crop: function(event) {
                        // Обновляем поля размеров при изменении crop рамки
                        updateCropSizeInputs();
                    }
                });

                // Заполняем поля начальными размерами
                updateCropSizeInputs();
            };
        }

        function applyCrop() {
            if (!cropper) return;

            saveToHistory();

            const croppedCanvas = cropper.getCroppedCanvas();

            // Возвращаем canvas на место
            const cropperContainer = document.getElementById('cropper-container');
            const canvasContainer = cropperContainer.parentNode;

            canvas.width = croppedCanvas.width;
            canvas.height = croppedCanvas.height;
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.drawImage(croppedCanvas, 0, 0);

            canvasContainer.replaceChild(canvas, cropperContainer);
            cropper.destroy();
            cropper = null;

            // Очищаем сохраненное состояние, так как обрезка применена
            canvasStateBeforeCrop = null;
        }

        function cancelCrop() {
            if (!cropper) return;

            // Возвращаем canvas на место и восстанавливаем предыдущее состояние
            const cropperContainer = document.getElementById('cropper-container');
            const canvasContainer = cropperContainer.parentNode;

            canvasContainer.replaceChild(canvas, cropperContainer);
            cropper.destroy();
            cropper = null;

            // Восстанавливаем состояние canvas до активации cropper
            if (canvasStateBeforeCrop) {
                try {
                    canvas.width = canvasStateBeforeCrop.width;
                    canvas.height = canvasStateBeforeCrop.height;
                    context.putImageData(canvasStateBeforeCrop.imageData, 0, 0);
                } catch (e) {
                    console.warn('Could not restore canvas state:', e);
                }
                canvasStateBeforeCrop = null;
            }
        }

        // Функции работы с водяными знаками
        function loadWatermarks() {
            if (watermarksLoaded) return;

            console.log('Loading watermarks...');

            $.ajax({
                url: '{% url "image_editor:list_watermarks" %}',
                method: 'GET',
                success: function(data) {
                    const select = document.getElementById('watermark-select');
                    select.innerHTML = '<option value="">Выберите водяной знак</option>';

                    data.watermarks.forEach(function(watermark) {
                        const option = document.createElement('option');
                        option.value = watermark.id;
                        option.textContent = watermark.label;
                        select.appendChild(option);
                    });

                    watermarksLoaded = true;
                    console.log('Watermarks loaded:', data.watermarks.length);
                },
                error: function(xhr, status, error) {
                    console.error('Failed to load watermarks:', error);
                    const select = document.getElementById('watermark-select');
                    select.innerHTML = '<option value="">Ошибка загрузки</option>';
                }
            });
        }

        function loadWatermarkImage(assetId) {
            return $.ajax({
                url: '{% url "image_editor:get_watermark" 0 %}'.replace('0', assetId),
                method: 'GET'
            });
        }

        function applyWatermark() {
            const watermarkSelect = document.getElementById('watermark-select');
            const selectedId = watermarkSelect.value;

            if (!selectedId) {
                alert('Выберите водяной знак');
                return;
            }

            console.log('Applying watermark:', selectedId);

            loadWatermarkImage(selectedId).done(function(data) {
                saveToHistory();

                const watermarkImg = new Image();
                watermarkImg.onload = function() {
                    // Настройки водяного знака
                    const opacity = parseInt(document.getElementById('watermark-opacity').value) / 100;
                    const position = document.getElementById('watermark-position').value;
                    const scale = parseInt(document.getElementById('watermark-scale').value) / 100;

                    // Рассчитываем размеры водяного знака
                    const watermarkWidth = watermarkImg.width * scale;
                    const watermarkHeight = watermarkImg.height * scale;

                    // Рассчитываем позицию
                    let x, y;
                    switch (position) {
                        case 'center':
                            x = (canvas.width - watermarkWidth) / 2;
                            y = (canvas.height - watermarkHeight) / 2;
                            break;
                        case 'top-left':
                            x = 10;
                            y = 10;
                            break;
                        case 'top-right':
                            x = canvas.width - watermarkWidth - 10;
                            y = 10;
                            break;
                        case 'bottom-left':
                            x = 10;
                            y = canvas.height - watermarkHeight - 10;
                            break;
                        case 'bottom-right':
                            x = canvas.width - watermarkWidth - 10;
                            y = canvas.height - watermarkHeight - 10;
                            break;
                        case 'custom':
                            x = parseInt(document.getElementById('watermark-x').value) || 0;
                            y = parseInt(document.getElementById('watermark-y').value) || 0;
                            break;
                    }

                    // Сохраняем текущее состояние canvas
                    context.save();

                    // Устанавливаем прозрачность
                    context.globalAlpha = opacity;

                    // Рисуем водяной знак
                    context.drawImage(watermarkImg, x, y, watermarkWidth, watermarkHeight);

                    // Восстанавливаем состояние canvas
                    context.restore();

                    console.log('Watermark applied successfully');
                };
                watermarkImg.src = data.data_url;
            }).fail(function(xhr, status, error) {
                console.error('Failed to load watermark image:', error);
                alert('Ошибка загрузки водяного знака');
            });
        }

        // Инициализация Canvas
        function initializeCanvas() {
            const documentFileId = window.imageEditorConfig.documentFileId;
            const mimetype = '{{ document_file.mimetype|default:"" }}';
            const filename = '{{ document_file.filename|default:"" }}';

            console.log('Initializing canvas with:', {
                documentFileId,
                mimetype,
                filename,
                config: window.imageEditorConfig
            });

            if (!documentFileId || documentFileId === 'null') {
                console.error('Document file ID is not available');
                showError('Файл не найден или недоступен.');
                return;
            }

            if (!mimetype || !mimetype.startsWith('image/')) {
                console.error('File is not an image:', mimetype);
                showError('Выбранный файл не является изображением.');
                return;
            }

            const apiUrl = '{{ document_file.get_api_image_url|default:"" }}';
            console.log('API URL:', apiUrl);

            if (!apiUrl || apiUrl.trim() === '') {
                console.error('API image URL is not available or empty');
                showError('Не удалось получить URL изображения.');
                return;
            }

            // Показываем индикатор загрузки
            const canvasWrapper = document.querySelector('.image-editor__canvas-wrapper');
            const loadingIndicator = document.createElement('div');
            loadingIndicator.innerHTML = `
                <div class="text-center" style="padding: 40px;">
                    <i class="fa fa-spinner fa-spin fa-2x"></i>
                    <p style="margin-top: 10px;">Загрузка изображения...</p>
                </div>
            `;
            canvasWrapper.appendChild(loadingIndicator);

            sourceImage.src = apiUrl;
            sourceImage.onload = function() {
                console.log('Image loaded successfully:', sourceImage.naturalWidth, 'x', sourceImage.naturalHeight);
                canvas.width = sourceImage.naturalWidth;
                canvas.height = sourceImage.naturalHeight;

                if (canvas.width > 0 && canvas.height > 0) {
                    context.drawImage(sourceImage, 0, 0);

                    if (loadingIndicator && loadingIndicator.parentNode) {
                        loadingIndicator.parentNode.removeChild(loadingIndicator);
                    }

                    setTimeout(() => saveToHistory(), 100);
                } else {
                    console.error('Failed to load image - invalid dimensions');
                    if (loadingIndicator && loadingIndicator.parentNode) {
                        loadingIndicator.parentNode.removeChild(loadingIndicator);
                    }
                    showError('Изображение имеет некорректные размеры.');
                }
            };

            sourceImage.onerror = function(e) {
                console.error('Failed to load image from API URL:', apiUrl, e);

                if (loadingIndicator && loadingIndicator.parentNode) {
                    loadingIndicator.parentNode.removeChild(loadingIndicator);
                }

                console.log('Trying fallback loading...');
                fetch('/documents/documents/files/' + documentFileId + '/preview/', {
                    method: 'GET',
                    headers: {
                        'X-CSRFToken': "{{ csrf_token }}",
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    credentials: 'same-origin'
                })
                .then(response => {
                    console.log('Fallback fetch response:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    console.log('Blob received, size:', blob.size);
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                })
                .then(dataUrl => {
                    console.log('Data URL created, setting as src');
                    sourceImage.src = dataUrl;
                })
                .catch(error => {
                    console.error('Fallback loading also failed:', error);
                    showError('Не удалось загрузить изображение. Попробуйте другой файл.');
                });
            };

            if (sourceImage.complete) {
                sourceImage.onload();
            }
        }

        // Обработчик клика по canvas для размещения текста
        function handleCanvasClick(event) {
            if (currentTool !== 'text') return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            textConfig.x = (event.clientX - rect.left) * scaleX;
            textConfig.y = (event.clientY - rect.top) * scaleY;
        }

        // Сохранение изображения
        function handleSave() {
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;

            tempContext.drawImage(canvas, 0, 0);

            if (currentFilters.brightness !== 0 || currentFilters.contrast !== 0 || currentFilters.filter !== 'none') {
                const imageData = tempContext.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;

                const brightness = (currentFilters.brightness / 100) + 1;
                const contrast = (currentFilters.contrast / 100) + 1;

                for (let i = 0; i < data.length; i += 4) {
                    data[i] *= brightness;
                    data[i + 1] *= brightness;
                    data[i + 2] *= brightness;

                    data[i] = ((data[i] - 128) * contrast) + 128;
                    data[i + 1] = ((data[i + 1] - 128) * contrast) + 128;
                    data[i + 2] = ((data[i + 2] - 128) * contrast) + 128;
                }

                switch (currentFilters.filter) {
                    case 'grayscale':
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                            data[i] = data[i + 1] = data[i + 2] = gray;
                        }
                        break;
                    case 'sepia':
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i], g = data[i + 1], b = data[i + 2];
                            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                            data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                            data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                        }
                        break;
                    case 'blur':
                        applyBoxBlur(data, tempCanvas.width, tempCanvas.height, 2);
                        break;
                    case 'sharpen':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, data[i] * 1.2);
                            data[i + 1] = Math.min(255, data[i + 1] * 1.2);
                            data[i + 2] = Math.min(255, data[i + 2] * 1.2);
                        }
                        break;
                }

                tempContext.putImageData(imageData, 0, 0);
            }

            const selectedFormat = formatField.value;
            const mimeType = selectedFormat === 'jpeg' ? 'image/jpeg' :
                             selectedFormat === 'png' ? 'image/png' :
                             selectedFormat === 'webp' ? 'image/webp' :
                             selectedFormat === 'tiff' ? 'image/tiff' : 'image/png';

            tempCanvas.toBlob(function(blob) {
                if (!blob) {
                    alert('Не удалось получить данные изображения');
                    return;
                }

                const fileName = `edited-image.${selectedFormat}`;
                const formData = new FormData();
                formData.append('image_content', blob, fileName);
                formData.append('comment', commentField.value);
                formData.append('format', selectedFormat);

                fetch(window.imageEditorConfig.saveUrl, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': window.imageEditorConfig.csrfToken
                    },
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Новая версия успешно сохранена.');
                        window.location.href = '/documents/documents/files/' + data.document_file_id + '/preview/';
                    } else {
                        alert('Ошибка при сохранении: ' + JSON.stringify(data.errors));
                    }
                })
                .catch(error => {
                    console.error('Save error:', error);
                    alert('Ошибка при сохранении файла.');
                });
            }, mimeType);
        }

        // Обработчики инструментов
        function handleToolClick(event) {
            const button = event.currentTarget;
            const tool = button.getAttribute('data-tool');

            document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            document.getElementById('drawing-settings').style.display = 'none';
            document.getElementById('text-settings').style.display = 'none';
            document.getElementById('crop-settings').style.display = 'none';
            document.getElementById('watermark-settings').style.display = 'none';

            currentTool = tool;

            switch (tool) {
                case 'brush':
                case 'eraser':
                    document.getElementById('drawing-settings').style.display = 'block';
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'text':
                    document.getElementById('text-settings').style.display = 'block';
                    canvas.style.cursor = 'text';
                    break;
                case 'crop':
                    document.getElementById('crop-settings').style.display = 'block';
                    initCropper();
                    break;
                case 'watermark':
                    document.getElementById('watermark-settings').style.display = 'block';
                    loadWatermarks();
                    break;
                case 'select':
                    canvas.style.cursor = 'default';
                    break;
                case 'rotate-left':
                    resetFilters();
                    saveToHistory();
                    rotateImage(-90);
                    break;
                case 'rotate-right':
                    resetFilters();
                    saveToHistory();
                    rotateImage(90);
                    break;
                case 'flip-horizontal':
                    resetFilters();
                    saveToHistory();
                    flipImage('horizontal');
                    break;
                case 'flip-vertical':
                    resetFilters();
                    saveToHistory();
                    flipImage('vertical');
                    break;
            }
        }

        // Поворот изображения
        function rotateImage(degrees) {
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');

            if (Math.abs(degrees) === 90) {
                tempCanvas.width = canvas.height;
                tempCanvas.height = canvas.width;

                tempContext.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                tempContext.rotate(degrees * Math.PI / 180);
                tempContext.translate(-canvas.width / 2, -canvas.height / 2);
                tempContext.drawImage(canvas, 0, 0);

                canvas.width = tempCanvas.width;
                canvas.height = tempCanvas.height;
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(tempCanvas, 0, 0);
            }
        }

        // Отражение изображения
        function flipImage(direction) {
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;

            tempContext.save();

            if (direction === 'horizontal') {
                tempContext.scale(-1, 1);
                tempContext.drawImage(canvas, -canvas.width, 0);
            } else if (direction === 'vertical') {
                tempContext.scale(1, -1);
                tempContext.drawImage(canvas, 0, -canvas.height);
            }

            tempContext.restore();

            context.clearRect(0, 0, canvas.width, canvas.height);
            context.drawImage(tempCanvas, 0, 0);
        }

        // Применение фильтров
        function applyFilters() {
            let filterParts = [];

            if (currentFilters.brightness !== 0 || currentFilters.contrast !== 0) {
                const brightness = (currentFilters.brightness / 100) + 1;
                const contrast = (currentFilters.contrast / 100) + 1;
                filterParts.push(`brightness(${brightness}) contrast(${contrast})`);
            }

            switch (currentFilters.filter) {
                case 'grayscale':
                    filterParts.push('grayscale(100%)');
                    break;
                case 'sepia':
                    filterParts.push('sepia(100%)');
                    break;
                case 'blur':
                    filterParts.push('blur(2px)');
                    break;
                case 'sharpen':
                    filterParts.push('contrast(1.2) brightness(1.1)');
                    break;
                case 'none':
                default:
                    break;
            }

            const filterString = filterParts.length > 0 ? filterParts.join(' ') : 'none';
            canvas.style.filter = filterString;
        }

        function resetFilters() {
            currentFilters.brightness = 0;
            currentFilters.contrast = 0;
            currentFilters.filter = 'none';
            brightnessControl.value = 0;
            contrastControl.value = 0;
            canvas.style.filter = 'none';

            document.querySelectorAll('[data-filter]').forEach(btn => btn.classList.remove('active'));
            document.querySelector('[data-filter="none"]').classList.add('active');
        }

        function handleBrightnessChange(event) {
            currentFilters.brightness = parseInt(event.target.value);
            applyFilters();
        }

        function handleContrastChange(event) {
            currentFilters.contrast = parseInt(event.target.value);
            applyFilters();
        }

        function handleFilterClick(event) {
            const button = event.currentTarget;
            const filter = button.getAttribute('data-filter');

            document.querySelectorAll('[data-filter]').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            currentFilters.filter = filter;
            applyFilters();
        }

        function handleBrushSizeChange(event) {
            brushSettings.brushSize = parseInt(event.target.value);
            brushSizeValue.textContent = brushSettings.brushSize;
        }

        function handleBrushColorChange(event) {
            brushSettings.brushColor = event.target.value;
        }

        function handleBrushOpacityChange(event) {
            brushSettings.brushOpacity = parseInt(event.target.value) / 100;
            brushOpacityValue.textContent = event.target.value;
        }

        function handleTextSizeChange(event) {
            textConfig.fontSize = parseInt(event.target.value);
            textSizeValue.textContent = textConfig.fontSize;
        }

        function handleTextColorChange(event) {
            textConfig.color = event.target.value;
        }

        function handleTextInputChange(event) {
            textConfig.text = event.target.value;
        }

        function addText() {
            if (!textConfig.text.trim()) {
                alert('Введите текст для добавления');
                return;
            }

            saveToHistory();

            context.save();
            context.font = `${textConfig.fontSize}px Arial`;
            context.fillStyle = textConfig.color;
            context.fillText(textConfig.text, textConfig.x, textConfig.y);
            context.restore();
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #f8d7da; color: #721c24; padding: 20px; border: 1px solid #f5c6cb; border-radius: 5px; z-index: 10000;';
            errorDiv.innerHTML = `<strong>Ошибка:</strong> ${message}<br><button onclick="this.parentNode.remove()" style="margin-top: 10px;">Закрыть</button>`;
            document.body.appendChild(errorDiv);
        }

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        function startDrawing(event) {
            if (currentTool !== 'brush' && currentTool !== 'eraser') return;

            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            lastX = (event.clientX - rect.left) * scaleX;
            lastY = (event.clientY - rect.top) * scaleY;

            saveToHistory();
        }

        function draw(event) {
            if (!isDrawing || (currentTool !== 'brush' && currentTool !== 'eraser')) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const currentX = (event.clientX - rect.left) * scaleX;
            const currentY = (event.clientY - rect.top) * scaleY;

            context.save();

            if (currentTool === 'brush') {
                context.globalAlpha = brushSettings.brushOpacity;
                context.strokeStyle = brushSettings.brushColor;
                context.lineWidth = brushSettings.brushSize;
                context.lineCap = 'round';
                context.lineJoin = 'round';
            } else if (currentTool === 'eraser') {
                context.globalCompositeOperation = 'destination-out';
                context.lineWidth = brushSettings.brushSize;
            }

            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(currentX, currentY);
            context.stroke();

            context.restore();

            lastX = currentX;
            lastY = currentY;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // Инициализация
        function init() {
            console.log('Initializing image editor...');

            initializeCanvas();

            document.querySelectorAll('[data-tool]').forEach(button => {
                button.addEventListener('click', handleToolClick);
            });

            brightnessControl.addEventListener('input', handleBrightnessChange);
            contrastControl.addEventListener('input', handleContrastChange);

            document.querySelectorAll('[data-filter]').forEach(button => {
                button.addEventListener('click', handleFilterClick);
            });

            brushSizeControl.addEventListener('input', handleBrushSizeChange);
            brushColorControl.addEventListener('input', handleBrushColorChange);
            brushOpacityControl.addEventListener('input', handleBrushOpacityChange);

            textInput.addEventListener('input', handleTextInputChange);
            textSizeControl.addEventListener('input', handleTextSizeChange);
            textColorControl.addEventListener('input', handleTextColorChange);
            addTextBtn.addEventListener('click', addText);

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            // Обработчики для crop
            document.getElementById('apply-size-btn').addEventListener('click', applyCropSize);
            document.getElementById('apply-crop-btn').addEventListener('click', applyCrop);
            document.getElementById('cancel-crop-btn').addEventListener('click', cancelCrop);

            // Обработчики для водяных знаков
            document.getElementById('watermark-position').addEventListener('change', function() {
                const customPosition = document.getElementById('watermark-custom-position');
                if (this.value === 'custom') {
                    customPosition.style.display = 'block';
                } else {
                    customPosition.style.display = 'none';
                }
            });
            document.getElementById('watermark-opacity').addEventListener('input', function() {
                document.getElementById('watermark-opacity-value').textContent = this.value;
            });
            document.getElementById('watermark-scale').addEventListener('input', function() {
                document.getElementById('watermark-scale-value').textContent = this.value;
            });
            document.getElementById('apply-watermark-btn').addEventListener('click', applyWatermark);

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('click', handleCanvasClick);

            saveButton.addEventListener('click', handleSave);

            document.querySelector('[data-filter="none"]').classList.add('active');
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
</script>
{% endblock %}
